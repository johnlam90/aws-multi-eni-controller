apiVersion: apps/v1
kind: Deployment
metadata:
  name: dpdk-controller
  namespace: dpdk-operator
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dpdk-controller
  template:
    metadata:
      labels:
        app: dpdk-controller
    spec:
      serviceAccountName: dpdk-operator
      containers:
      - name: controller
        image: alpine:3.19
        command: ["/bin/sh", "-c"]
        resources:
          limits:
            cpu: "500m"
            memory: "256Mi"
          requests:
            cpu: "100m"
            memory: "128Mi"
        args:
        - |
          # Install required packages
          apk --no-cache add curl jq
          
          # Function to process DPDKConfig resources
          process_dpdk_configs() {
            echo "Processing DPDKConfig resources..."
            
            # Get all DPDKConfig resources
            CONFIGS=$(kubectl get dpdkconfigs -o json)
            
            # Process each config
            echo "$CONFIGS" | jq -c '.items[]' | while read -r config; do
              name=$(echo "$config" | jq -r '.metadata.name')
              echo "Processing DPDKConfig: $name"
              
              # Get node selector
              nodeSelector=$(echo "$config" | jq -r '.spec.nodeSelector')
              
              # Get matching nodes
              nodeSelectors=""
              echo "$nodeSelector" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while read -r selector; do
                if [ -z "$nodeSelectors" ]; then
                  nodeSelectors="$selector"
                else
                  nodeSelectors="$nodeSelectors,$selector"
                fi
              done
              
              nodes=$(kubectl get nodes -l "$nodeSelectors" -o json | jq -r '.items[].metadata.name')
              
              # Process each node
              for node in $nodes; do
                echo "Processing node: $node"
                
                # Label node for DPDK
                kubectl label node "$node" dpdk.aws.k8s/enabled=true --overwrite
                
                # Get resource mappings
                resourceMappings=$(echo "$config" | jq -c '.spec.resourceMapping[]')
                
                # Process each resource mapping
                echo "$resourceMappings" | while read -r mapping; do
                  deviceIndex=$(echo "$mapping" | jq -r '.deviceIndex')
                  resourceName=$(echo "$mapping" | jq -r '.resourceName')
                  driver=$(echo "$mapping" | jq -r '.driver')
                  
                  echo "Configuring device index $deviceIndex with resource name $resourceName using driver $driver"
                  
                  # Find NodeENI resources that match this node and device index
                  nodeENIs=$(kubectl get nodeenis -o json | jq -c ".items[] | select(.spec.deviceIndex == $deviceIndex)")
                  
                  # Update each matching NodeENI
                  echo "$nodeENIs" | while read -r nodeENI; do
                    nodeENIName=$(echo "$nodeENI" | jq -r '.metadata.name')
                    
                    # Check if this NodeENI applies to our node
                    nodeENISelector=$(echo "$nodeENI" | jq -r '.spec.nodeSelector')
                    matches=false
                    
                    echo "$nodeENISelector" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while read -r selector; do
                      if kubectl get node "$node" -o json | jq -r '.metadata.labels' | grep -q "\"$(echo "$selector" | cut -d= -f1)\": \"$(echo "$selector" | cut -d= -f2)\""; then
                        matches=true
                      fi
                    done
                    
                    if [ "$matches" = "true" ]; then
                      echo "Updating NodeENI $nodeENIName for DPDK"
                      
                      # Patch the NodeENI to enable DPDK
                      kubectl patch nodeeni "$nodeENIName" --type=merge -p "{\"spec\":{\"enableDPDK\":true,\"dpdkDriver\":\"$driver\",\"dpdkResourceName\":\"$resourceName\"}}"
                    fi
                  done
                done
                
                # Update DPDKConfig status
                nodesReady=$(kubectl get dpdkconfig "$name" -o json | jq -r '.status.nodesReady // []')
                if ! echo "$nodesReady" | grep -q "$node"; then
                  nodesReady=$(echo "$nodesReady" | jq -r '. + ["'"$node"'"]')
                  kubectl patch dpdkconfig "$name" --type=merge -p "{\"status\":{\"nodesReady\":$nodesReady}}"
                fi
              done
              
              # Update DPDKConfig status condition
              kubectl patch dpdkconfig "$name" --type=merge -p '{"status":{"conditions":[{"type":"Ready","status":"True","lastTransitionTime":"'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'","reason":"ConfigApplied","message":"DPDK configuration applied to all nodes"}]}}'
            done
          }
          
          # Main loop
          while true; do
            process_dpdk_configs
            sleep 60
          done
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: dpdk-controller
  namespace: dpdk-operator
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: dpdk-controller
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch", "patch"]
- apiGroups: ["networking.k8s.aws"]
  resources: ["dpdkconfigs", "nodeenis"]
  verbs: ["get", "list", "watch", "update", "patch"]
- apiGroups: ["networking.k8s.aws"]
  resources: ["dpdkconfigs/status"]
  verbs: ["update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: dpdk-controller
subjects:
- kind: ServiceAccount
  name: dpdk-controller
  namespace: dpdk-operator
roleRef:
  kind: ClusterRole
  name: dpdk-controller
  apiGroup: rbac.authorization.k8s.io
